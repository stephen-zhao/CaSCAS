//=============================================================================
// lang/Context.scala : CaSCAS Project
//=============================================================================
// A Context is used in the runtime to represent a mapping from identifiers
// (names) to either types or type-value pairs.
//
// A mapping from an identifier to a type represents a declaration of a name
// that hasn't been assigned. e.g. a formal parameter definition.
//
// A mapping from an identifier to a type-value pair (TypedObject) represents
// a name that was assigned a object (and which has a type association).

package org.cascas_project.cascas.lang

//=============================================================================

import org.cascas_project.cascas.lang.liro.Identifier

//=============================================================================

case class Context private(
  m: Map[Identifier, ContextValue],
  autoGeneratedTypeCurrentIndex: Int
) {

  def get(key: Identifier): Option[ContextValue] = m.get(key)

  def iterator: Iterator[(Identifier, ContextValue)] = m.iterator

  def toMap: Map[Identifier, ContextValue] = m

  override def toString: String = {
    "Context containing {\n" +
    this.m.map{ case (k, v) => f"$k : $v" }.mkString("\n") +
    "\n}"
  }

  // ConsolidatedWith is used to incorporate context changes gathered in a
  // ContextMutationSet into a Context. ContextMutationSet breaks down the
  // changes into three components: introductions, assignments, and
  // reassignments, and each of these must be handled appropriately.
  def consolidatedWith(ctxDelta: ContextMutationSet): Context = {
    val intros:    Map[Identifier, ContextValue] = ctxDelta.getIntroductions
    val assigns:   Map[Identifier, ContextValue] = ctxDelta.getAssignments
    val reassigns: Map[Identifier, ContextValue] = ctxDelta.getReassignments

    val intermediateM: Map[Identifier, ContextValue] = this.m ++ intros ++ assigns

    val filteredReassigns = reassigns.filter {
      case (k, v) => !(intermediateM contains k)
    }

    Context(intermediateM ++ filteredReassigns, this.getUpdatedAutoGeneratedTypeCurrentIndex)
  }

  def :+(ctxDelta: ContextMutationSet): Context = consolidatedWith(ctxDelta)

  def contains(ident: Identifier): Boolean = this.m contains ident

  def getUpdatedAutoGeneratedTypeCurrentIndex: Int = {
    var autoGeneratedTypeIndex = this.autoGeneratedTypeCurrentIndex
    while(this.m contains Identifier("__TYPE_"+autoGeneratedTypeIndex)) {
      autoGeneratedTypeIndex = autoGeneratedTypeIndex + 1
    }
    autoGeneratedTypeIndex
  }

  def generateNextUniqueTypeIdentifier(): TypeIdentifier = {
    val supposedNextUniqueTypeIdentifier = Identifier("__TYPE_"+this.autoGeneratedTypeCurrentIndex)
    if (this.m contains supposedNextUniqueTypeIdentifier) {
      throw new Exception("Impossible...") //TODO
    }
    else {
      Identifier("__TYPE_" + this.autoGeneratedTypeCurrentIndex)
    }
  }

}

object Context {
  val empty = Context(Map[Identifier, ContextValue](), 0)
}

trait ContextValue {}
